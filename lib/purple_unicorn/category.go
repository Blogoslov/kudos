package purple_unicorn

import (
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"os"
)

const CategoryConfigFileName = "config.json"

//This file contains experimental work on dealing with course 'categories': A
//layer of abstraction that sits on top of assignments to assign weights
//between groups of assignments. I.e. A course may have different assignments
//be designated as "Homework" or "Projects". This framework allows arbitrary
//trees of categories.
//From a UI/organizational perspective, we have two options on how to organize
//categories:
// - Force each config file to list all of its children explicitly
//    (e.g. "children"  : ["foo/file1.json", "bar/file2.json"...])
// - Deduce the location of subcategories based on subdirectories.
//Luckily the overall API will remain the same regardless, but this does
//significantly change parsing

type Weight uint64

type Category interface {
	Children() []Category
	SetChildren([]Category)
	Name() string
	//This is a bit of an implementation detail, but given that this is purely
	//config information, the API is designed to be consumed by the database
	//and the grading systems
	Weight() Weight
	//shallow, only searches one level
	Assignments() []Assignment
	SetAssignments([]Assignment)
}

//This is the root of the category tree. It is never parsed because it is
//implicitly generated by a course config.
type RootCategory struct {
	name     string
	children []Category
	asgns    []Assignment
}

func (r RootCategory) Children() []Category {
	return r.children
}

func (r RootCategory) Name() string {
	return r.name
}

func (r RootCategory) SetChildren(c []Category) {
	r.children = c
}

func (r RootCategory) Weight() Weight {
	return Weight(1)
}

func (r RootCategory) Assignments() []Assignment {
	return r.asgns
}
func (r RootCategory) SetAssignments(a []Assignment) {
	r.asgns = a
}

type branchCategory struct {
	Name   *string `json:"category"`
	Weight *uint64 `json:"weight"`
}

//Recursively traverse directory tree, building up category structure.
//The base case of the recursion is the root category generated from a course config along
//with the directory to start searching for configs
func ParseBranchCategory(parent Category, dir string) error {
	var errs ErrList
	files, err := ioutil.ReadDir(dir)
	if err != nil {
		return fmt.Errorf("error reading directory %v: %v", dir, err)
	}
	toTraverse := []os.FileInfo{}
	var newParent Category

again:
	for _, f := range files {
		if f.IsDir() {
			if newParent == nil {
				toTraverse = append(toTraverse, f)
			} else {
				err = ParseBranchCategory(newParent, fmt.Sprintf("%s/%s", dir, f.Name()))
				if err != nil {
					errs.Add(fmt.Errorf("unable to parse directory %s/%s: %v", dir, f.Name(), err))
				}
			}
		} else if f.Name() == CategoryConfigFileName {
			r, err := os.Open(fmt.Sprintf("%s/%s", dir, f.Name()))
			if err != nil {
				errs.Add(fmt.Errorf("unable to open file %s/%s", dir, f.Name()))
				return errs
			}
			if b, err := parseBranchCategory(r); err != nil {
				errs.Add(fmt.Errorf("unable to parse category config %s/%s: %v", dir, f.Name(), err))
				return errs
			} else {
				if newParent != nil {
					// this is a programmer error as it would imply that there
					// is more than one file in this directory with this name
					panic("Internal Error: Multiple config files found")
				}
				newParent = BranchCategory{
					name:   *b.Name,
					weight: Weight(*b.Weight),
				}
				parent.SetChildren(append(parent.Children(), newParent))
			}
		} else {
			// We have found a file -- presumably this means it is an assignment
			a, err := ParseAssignmentFile(fmt.Sprintf("%s/%s", dir, f.Name()))
			if err != nil {
				errs.Add(err)
			} else {
				parent.SetAssignments(append(parent.Assignments(), *a))
			}
		}
	}

	//If we encountered some directories before parsing the config file, then
	//we need to traverse them
	if len(toTraverse) != 0 {
		files = toTraverse
		toTraverse = nil
		goto again
	}

	return errs
}

func parseBranchCategory(r io.Reader) (branchCategory, error) {
	var errs ErrList
	d := json.NewDecoder(r)
	var b branchCategory
	err := d.Decode(&b)
	if err != nil {
		return branchCategory{}, err
	}
	if b.Name == nil {
		errs.Add(fmt.Errorf("must add \"category\" field"))
	}
	if b.Weight == nil {
		errs.Add(fmt.Errorf("must add \"weight\" field"))
	}
	if len(errs) == 0 {
		return b, nil
	} else {
		return branchCategory{}, errs
	}

}

type BranchCategory struct {
	name     string
	children []Category
	asgns    []Assignment
	weight   Weight
}

func (b BranchCategory) Validate() error {
	if b.children != nil && b.asgns != nil {
		return fmt.Errorf(`Category %v has the following children that are subcatecories:
%v
and the following children that are assignments:
%v
Categories may only have one or the other`, b.name, b.children, b.asgns)
	}
	return nil
}

func (b BranchCategory) Children() []Category {
	return b.children
}

func (b BranchCategory) Assignments() []Assignment {
	return b.asgns
}

func (b BranchCategory) Weight() Weight {
	return b.weight
}
func (b BranchCategory) Name() string {
	return b.name
}
func (b BranchCategory) SetChildren(c []Category) {
	b.children = c
}
func (b BranchCategory) SetAssignments(a []Assignment) {
	b.asgns = a
}

// A similar recursive strategy can/should be used to generate a
// pretty-printing method for showing what the course structure looks like.  A
// more general framework along those lines would be to allow for it to render
// html/latex for course documentation.
func GetAssignments(c Category) []Assignment {
	var res []Assignment
	if children := c.Children(); len(children) != 0 {
		for _, ch := range children {
			res = append(res, GetAssignments(ch)...)
		}
	} else {
		res = c.Assignments()
	}
	return res
}
